#!/usr/bin/env python3
# ruff: noqa: F405, F403, E402
import sys
from operator import and_ as AND
from operator import or_ as OR
from operator import xor as XOR

inputfile = sys.argv[1] if len(sys.argv) > 1 else "input.txt"
starting_values, connections = open(inputfile).read().strip().split("\n\n")

zs = 0

connections = [
    (a, op, b, c)
    for line in connections.splitlines()
    for a, op, b, _, c in [line.split()]
]

for line in starting_values.splitlines():
    exec(line.replace(":", "=lambda:"))

for conn in connections:
    a, op, b, c = conn
    exec(f"{c}=lambda:{op}({a}(),{b}())")
    if c[0] == "z":
        zs += 1

max_z = f"z{zs-1:02}"

print(sum(eval(f"z{i:02}()<<{i}") for i in range(zs)))

# A Full Adder computes the sum of three binary bits at each stage
# A, B, and a carry-in Cin
# and outputs two binary bits
# Sum S - the sum of A, B, and Cin
# Carry-out Cout - the carry generated by the addition

# At each stage the sum is computed as:
# S = (A XOR B) XOR Cin
# and the carry is computed as:
# Cout = (A AND B) OR (Cin AND (A XOR B))

# filter_conditions is looking for connections for which this relation is not true

# Condition 1 is looking for XOR gates that have all inputs as x, y, or z
#   this is invalid because XOR occurs when either
#   - both inputs are x,y and output is intermediate
#   - one input is x or y, and the other is Cin and output is z

# Condition 2 is looking for AND gates where the output is not used in a subsequent OR gate
#   this is only valid if one of the inputs is the least significant bit of x (x00)
#   as in this case the next gates will be XOR (as Cin for z01) and AND (to comput Cout for z01)

# Condition 3 is looking for XOR gates where the output is used in a subsequent OR gate
#   OR can only follow AND
#   AND can follow XOR and OR
#   XOR can follow OR and AND (if x00 is one of the inputs)

# Condition 4 is looking for z gates are outputs of non-XOR gates
#   the only time this happens is when the most significant bit of z (max_z) is being written (OR)

# up checks subsequent connections for the specified operator
def up(output, operator):
    return any(
        (output == a or output == b) and op == operator for a, op, b, c in connections
    )

def filter_conditions():
    result = []
    for a, op, b, c in connections:
        if (
            # Condition 1
            (op == "XOR" and all(p[0] in "xyz" for p in (a, b, c)))
            or
            # Condition 2
            (op == "AND" and not up(c, "OR") and "x00" not in (a, b))
            or
            # Condition 3
            (op == "XOR" and up(c, "OR") and "x00" not in (a, b))
            or
            # Condition 4
            (op != "XOR" and c[0] == "z" and c != max_z)
        ):
            result.append(c)
    return result

filtered_outputs = filter_conditions()
sorted_outputs = sorted(filtered_outputs)
print(*sorted_outputs, sep=",")
